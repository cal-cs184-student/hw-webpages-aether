<html>
	<head>
		<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=default'></script>
		<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
		<style>
			h1 {
				text-align: center;
			}

			.container {
				margin: 0 auto;
				padding: 60px 10%;
			}

			figure {
				text-align: center;
			}

			img {
				display: inline-block;
			}

			h2 {
				text-align: center;
			}

			h3 {
				text-align: center;
				font-size: 30px;
			}

			body {
				font-family: 'Inter', sans-serif;
			}

			blockquote {
				background-color: #d3d3d3;
				padding: 10px 15px;
				border: 1px solid #888;
				color: #4a4a4a;
				font-size: 16px;
				font-style: normal;
				border-radius: 4px;
			}
		</style>
	</head>
	<body>
		<div class="container">
		<h1>CS184/284A Spring 2025 Homework 4 Write-Up</h1>
		<div style="text-align: center;">Names: Saathvik Selvan, Mehdi Khfifi</div>

		<br>

		Link to webpage: <a href="https://cal-cs184-student.github.io/hw-webpages-aether/hw4/index.html">https://cal-cs184-student.github.io/hw-webpages-aether/hw4/index.html</a>

		<br>

		Link to GitHub repository: <a href="https://github.com/cal-cs184-student/sp25-hw4-bungee-gum">https://github.com/cal-cs184-student/sp25-hw4-bungee-gum</a>

		<figure>
			<img src="clothsim.png" alt="Cloth draped over sphere" style="width:70%"/>
		</figure>

		<!--
		We've already added one heading per part, to make your write-up as navigable when grading. Please fit your write-up within these sections!
		-->

		<h2>Overview</h2>
		Give a high-level overview of what you implemented in this homework. Think about what you've built as a whole. Share your thoughts on what interesting things you've learned from completing the homework.

		<h2>Part 1: Masses and springs</h2>

		<blockquote>
			Take some screenshots of <code>scene/pinned2.json</code> from a viewing angle where you can clearly see the cloth wireframe to show the structure of your point masses and springs.
		</blockquote>

		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
			  <tr>
				<td style="text-align: center; padding: 10px">
				  <img src="imgs/part1_angle1.png" width="400px"/>
				</td>
				<td style="text-align: center; padding: 10px">
				  <img src="imgs/part1_angle2.png" width="400px"/>
				</td>
			  </tr>
			</table>
		</div>

		<blockquote>
			Show us what the wireframe looks like (1) without any shearing constraints, (2) with only shearing constraints, and (3) with all constraints.
		</blockquote>

		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
			  <tr>
				<td style="text-align: center; padding: 10px">
				  <img src="imgs/part1_noshear.png" width="400px"/>
				  <figcaption>Without shearing constraints</figcaption>
				</td>
				<td style="text-align: center; padding: 10px">
				  <img src="imgs/part1_shear.png" width="400px"/>
				  <figcaption>Only shearing constraints</figcaption>
				</td>
			  </tr>
			</table>
			<img src="imgs/part1_all.png" width="400px"/>
			<figcaption>With all constraints</figcaption>
		</div>

		<h2>Part 2: Simulation via numerical integration</h2>
		
		<!--
		<blockquote>
			Experiment with some the parameters in the simulation. To do so, pause the simulation at the start with <code>P</code>, modify the values of interest, and then resume by pressing <code>P</code> again. You can also restart the simulation at any time from the cloth's starting position by pressing <code>R</code>.
		</blockquote>
		-->

		<blockquote>
			Describe the effects of changing the spring constant <code>ks</code>; how does the cloth behave from start to rest with a very low <code>ks</code>? A high <code>ks</code>?
		</blockquote>

		<p>
			With a very low <code>ks</code>, the cloth will be very loose, have more motion, and generally have less stiffness. With a high <code>ks</code>, the cloth will be more rigid, have less motion, and generally have more stiffness. This makes sense since we have springs in between the particles that make up the cloth, and the stiffness of the springs is directly related to the stiffness of the cloth.
		</p>

		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
			  <tr>
				<td style="text-align: center; padding: 10px">
				  <img src="imgs/part2_ks_50.png" width="300px"/>
				  <figcaption><code>ks</code> = 50</figcaption>
				</td>
				<td style="text-align: center; padding: 10px">
				  <img src="imgs/part2_ks_500.png" width="300px"/>
				  <figcaption><code>ks</code> = 500</figcaption>
				</td>
			  </tr>
			  <tr>
				<td style="text-align: center; padding: 10px">
				  <img src="imgs/part2_ks_5000.png" width="300px"/>
				  <figcaption><code>ks</code> = 5000</figcaption>
				</td>
				<td style="text-align: center; padding: 10px">
				  <img src="imgs/part2_ks_50000.png" width="300px"/>
				  <figcaption><code>ks</code> = 50000</figcaption>
				</td>
			  </tr>
			</table>
		</div>

		<blockquote>
			What about for <code>density</code>?
		</blockquote>

		<p>
			Density essentially controls the mass of the cloth. With a very low <code>density</code>, the cloth will be very light and will not deform as much, almost like a sheet of paper. With a high <code>density</code>, the cloth will weigh more, deform more, and generally look similar to the cloth with a low <code>ks</code> spring constant. This is due to the fact that gravity (influenced by mass) directly opposes the spring force (influenced by <code>ks</code>).
		</p>

		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
			  <tr>
				<td style="text-align: center; padding: 10px">
				  <img src="imgs/part2_density_5.png" width="300px"/>
				  <figcaption><code>density</code> = 5</figcaption>
				</td>
				<td style="text-align: center; padding: 10px">
				  <img src="imgs/part2_density_15.png" width="300px"/>
				  <figcaption><code>density</code> = 15</figcaption>
				</td>
			  </tr>
			  <tr>
				<td style="text-align: center; padding: 10px">
				  <img src="imgs/part2_density_100.png" width="300px"/>
				  <figcaption><code>density</code> = 100</figcaption>
				</td>
				<td style="text-align: center; padding: 10px">
				  <img src="imgs/part2_density_1000.png" width="300px"/>
				  <figcaption><code>density</code> = 1000</figcaption>
				</td>
			  </tr>
			</table>
		</div>

		<blockquote>
			What about for <code>damping</code>?
		</blockquote>

		<p>
			Damping simulates the loss of energy due to internal friction, allowing the cloth to gradually come to rest without altering the forces acting upon it. With very low <code>damping</code>, the cloth behaves more elastically, bouncing excessively and taking a long time to settle. At moderate <code>damping</code> levels, the cloth loses energy more efficiently, reducing bounce and reaching a resting state more quickly. With high <code>damping</code>, the cloth exhibits minimal bounce and comes to rest smoothly upon reaching the bottom. However, excessive damping can cause the cloth to descend more slowly, as seen with damping levels of 80% and 100%.
		</p>

		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
			  <tr>
				<td style="text-align: center; padding: 10px">
				  <img src="imgs/part2_damping_0.png" width="300px"/>
				  <figcaption><code>damping</code> = 0</figcaption>
				</td>
				<td style="text-align: center; padding: 10px">
				  <img src="imgs/part2_damping_20.png" width="300px"/>
				  <figcaption><code>damping</code> = 0.2</figcaption>
				</td>
			  </tr>
			  <tr>
				<td style="text-align: center; padding: 10px">
				  <img src="imgs/part2_damping_80.png" width="300px"/>
				  <figcaption><code>damping</code> = 0.8</figcaption>
				</td>
				<td style="text-align: center; padding: 10px">
				  <img src="imgs/part2_damping_100.png" width="300px"/>
				  <figcaption><code>damping</code> = 1.0</figcaption>
				</td>
			  </tr>
			</table>
		</div>

		<!--
		<blockquote>
			For each of the above, observe any noticeable differences in the cloth compared to the default parameters and show us some screenshots of those interesting differences and describe when they occur.
		</blockquote>
		-->

		<blockquote>
			Show us a screenshot of your shaded cloth from <code>scene/pinned4.json</code> in its final resting state! If you choose to use different parameters than the default ones, please list them.
		</blockquote>

		<div style="display: flex; flex-direction: column; align-items: center;">
			<img src="imgs/part2_shading.png" width="400px"/>
		</div>

		<h2>Part 3: Handling collisions with other objects</h2>
		
		<blockquote>
			Describe your implementation of handling collisions with spheres and planes.
		</blockquote>

		For cloth-sphere intersections, we do the following:
		<ol>
			<li>
			  Check if a point mass is inside or intersecting the sphere by comparing the distance from the sphere's center to the point mass with the sphere's radius.
			</li>
			<li>
			  If an intersection is detected (i.e. the distance is less than the radius), project the point mass radially outward to the sphere's surface so that it lies just outside.
			</li>
			<li>
			  Scale the correction vector down by \(1 - f\) to account for friction, and add it to the point mass's <code>last_position</code>.
			</li>
		  </ol>
		  
		  For cloth-plane intersections, we do the following:
		  <ol>
			<li>
			  Determine whether a point mass has crossed from one side of the plane to the other between time steps by using the dot product of the point mass's position and the plane's normal vector. If the signs of the dot products using the current and previous positions are different, a crossing has occurred.
			</li>
			<li>
			  If a crossing is detected, move the point mass to the point of intersection with the plane, offset slightly along the normal vector (by <code>SURFACE_OFFSET</code>) to keep it just above the surface.
			</li>
			<li>
			  Scale the correction vector down by \(1 - f\) to account for friction, and add it to the point mass's <code>last_position</code>.
			</li>
		  </ol>

		<blockquote>
			Show us screenshots of your shaded cloth from <code>scene/sphere.json</code> in its final resting state on the sphere using the default <code>ks</code> = 5000 as well as with <code>ks</code> = 500 and <code>ks</code> = 50000. Describe the differences in the results.
		</blockquote>

		<p>
			We see that the smaller the <code>ks</code>, the more the cloth deforms and wraps around the sphere. This is consistent with Part 2, where we observed that a lower <code>ks</code> leads to greater deformation of the cloth. On the other hand, with a higher <code>ks</code>, the cloth does not fully wrap around the sphere. Instead, it loosely covers the sphere, with its springs providing increased rigidity to the cloth.
		</p>

		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
			  <tr>
				<td style="text-align: center; padding: 10px">
				  <img src="imgs/part3_sphere_500.png" width="300px"/>
				  <figcaption><code>ks</code> = 500</figcaption>
				</td>
				<td style="text-align: center; padding: 10px">
				  <img src="imgs/part3_sphere_5000.png" width="300px"/>
				  <figcaption><code>ks</code> = 5000</figcaption>
				</td>
				<td style="text-align: center; padding: 10px">
					<img src="imgs/part3_sphere_50000.png" width="300px"/>
					<figcaption><code>ks</code> = 50000</figcaption>
				</td>
			  </tr>
			</table>
		</div>

		<blockquote>
			Show us a screenshot of your shaded cloth lying peacefully at rest on the plane. If you haven't by now, feel free to express your colorful creativity with the cloth! (You will need to complete the shaders portion first to show custom colors.)
		</blockquote>

		<div style="display: flex; flex-direction: column; align-items: center;">
			<img src="imgs/part3_plane.png" width="400px"/>
		</div>

		<h2>Part 4: Handling self-collisions</h2>
		
		<blockquote>
			Describe your implementation of handling self-collisions.
		</blockquote>

		<p>
			To efficiently resolve self-collisions in the cloth simulation, I used spatial hashing to group nearby point masses and limit unnecessary pairwise comparisons. The spatial map is built in <code>build_spatial_map()</code> by hashing each point mass's position into a 3D grid cell. The <code>hash_position()</code> function computes this hash by first dividing space into boxes of size <code>w = 3 * width / num_width_points</code>, <code>h = 3 * height / num_height_points</code>, and <code>t = max(w, h)</code> — and then floors  the position coordinates to determine the grid cell. The final hash is calculated as <code>i + j * range + k * range * range</code>, where <code>i</code>, <code>j</code>, and <code>k</code> are the floored grid indices and <code>range</code> is a large constant (e.g., 100000) to ensure uniqueness.
			</p>
			
			<p>
			During collision resolution in <code>self_collide()</code>, only the point masses within the same cell are checked. If another point mass is within <code>2 * thickness</code>, a correction vector is computed to push the masses apart. This correction is accumulated across all collisions, averaged, and applied to the current point mass's position, scaled by <code>simulation_steps</code> to ensure smooth separation.
			</p>

		<blockquote>
			Show us at least 3 screenshots that document how your cloth falls and folds on itself, starting with an early, initial self-collision and ending with the cloth at a more restful state (even if it is still slightly bouncy on the ground).
		</blockquote>

		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
			  <tr>
				<td style="text-align: center; padding: 10px">
				  <img src="imgs/part4_fall1.png" width="300px"/>
				  <figcaption>Frame 1</figcaption>
				</td>
				<td style="text-align: center; padding: 10px">
				  <img src="imgs/part4_fall2.png" width="300px"/>
				  <figcaption>Frame 2</figcaption>
				</td>
			  </tr>
			  <tr>
				<td style="text-align: center; padding: 10px">
				  <img src="imgs/part4_fall3.png" width="300px"/>
				  <figcaption>Frame 3</figcaption>
				</td>
				<td style="text-align: center; padding: 10px">
				  <img src="imgs/part4_fall4.png" width="300px"/>
				  <figcaption>Frame 4</figcaption>
				</td>
			  </tr>
			</table>
		</div>

		<blockquote>
			Vary the density as well as ks and describe with words and screenshots how they affect the behavior of the cloth as it falls on itself.
		</blockquote>

		<h2>Part 5: Shaders</h2>
		
		<blockquote>
			Explain in your own words what is a shader program and how vertex and fragment shaders work together to create lighting and material effects.
		</blockquote>

		<p>
			A shader program is a small program written in GLSL that is used to control how graphics are rendered. It typically consists of two parts: a vertex shader and a fragment shader. The vertex shader processes each vertex, applying transformations like position and normal vector calculations. It outputs the final vertex position and other values (called varyings) to be used later.
		</p>

		<p>
			The fragment shader then takes over after the scene has been rasterized into fragments (potential pixels). It uses the data passed from the vertex shader to determine the final color of each fragment, writing it into <code>out_color</code>. Together, these shaders create visual effects like lighting and materials by controlling how geometry is transformed and how pixels are colored based on light, texture, and surface properties.
		</p>

		<blockquote>
			Explain the Blinn-Phong shading model in your own words. Show a screenshot of your Blinn-Phong shader outputting only the ambient component, a screen shot only outputting the diffuse component, a screen shot only outputting the specular component, and one using the entire Blinn-Phong model.
		</blockquote>

		<p>
			The <strong>Blinn-Phong shading model</strong> is a lighting model used to simulate the interaction of light with a surface. It is composed of three key lighting components—<em>ambient</em>, <em>diffuse</em>, and <em>specular</em>—which are calculated per vertex in the shader. Each component captures a different physical behavior of light and contributes to the realism of rendered scenes.
		</p>

		<p>
			The ambient component approximates the background light that is scattered uniformly throughout the scene. In the real world, this light would come from indirect bounces off walls and other surfaces, but in our simplified model, it is represented as a constant value. This ensures that objects remain visible even when they aren't directly lit. In the shader, we model this as:
		</p>

		<pre><code>vec3 amb = vec3(ka);</code></pre>
		<p>
			where <code>ka</code> is a small constant (e.g., 0.1) representing ambient reflectivity. This term is independent of light direction or surface orientation.
		</p>

		<p>
			The diffuse component represents the scattering of light across a rough surface. It depends on the angle between the surface normal and the light direction, following Lambert's cosine law. This models how surfaces appear brightest when directly facing the light and dimmer when tilted away. In the shader, we compute it as:
		</p>

		<pre><code>vec3 diff = kd * ir2 * max(dot(normal, light_dir), 0.0);</code></pre>
		<p>
			Here, <code>kd</code> is the diffuse reflectance coefficient, and <code>ir2</code> accounts for the light intensity (via the inverse square law). The <code>dot(normal, light_dir)</code> term ensures light only contributes when it is hitting the front of the surface.
		</p>

		<p>
			The specular component models the bright highlights that appear on shiny surfaces where light reflects directly toward the viewer. Instead of using the traditional reflection vector, the Blinn-Phong model introduces a <strong>halfway vector</strong> between the light direction and the view direction:
		</p>

		<pre><code>vec3 halfway_dir = normalize(view_dir + light_dir);</code></pre>

		<p>
			The intensity of the specular highlight is determined by the dot product of the normal and this halfway vector, raised to a power <code>p</code> that controls the shininess. The higher the power, the smaller and sharper the highlight:
		</p>

		<pre><code>vec3 spec = ks * ir2 * pow(max(dot(normal, halfway_dir), 0.0), p);</code></pre>

		<p>
			Here, <code>ks</code> is the specular reflectivity, and <code>p</code> controls how quickly the specular reflection falls off. A value like <code>p = 100</code> represents a very shiny surface, while lower values produce broader highlights.
		</p>

		<p>
			The final light intensity <code>L</code> at a point is the sum of the ambient, diffuse, and specular terms:
		</p>

		<pre><code>out_color = vec4(amb + diff + spec, 1.0);</code></pre>

		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
			  <tr>
				<td style="text-align: center; padding: 10px">
				  <img src="imgs/part5_ambient.png" width="300px"/>
				  <figcaption>Ambient Component</figcaption>
				</td>
				<td style="text-align: center; padding: 10px">
				  <img src="imgs/part5_diffuse.png" width="300px"/>
				  <figcaption>Diffuse Component</figcaption>
				</td>
			  </tr>
			  <tr>
				<td style="text-align: center; padding: 10px">
				  <img src="imgs/part5_specular.png" width="300px"/>
				  <figcaption>Specular Component</figcaption>
				</td>
				<td style="text-align: center; padding: 10px">
				  <img src="imgs/part5_phong.png" width="300px"/>
				  <figcaption>Entire Blinn-Phong</figcaption>
				</td>
			  </tr>
			</table>
		</div>

		<blockquote>
			Show a screenshot of your texture mapping shader using your own custom texture by modifying the textures in /textures/.
		</blockquote>

		<div style="display: flex; flex-direction: column; align-items: center;">
			<img src="imgs/part5_texture.png" width="400px"/>
		</div>

		<blockquote>
			Show a screenshot of bump mapping on the cloth and on the sphere. Show a screenshot of displacement mapping on the sphere. Use the same texture for both renders. You can either provide your own texture or use one of the ones in the textures directory, BUT choose one that's not the default <code>texture_2.png</code>. Compare the two approaches and resulting renders in your own words. Compare how your the two shaders react to the sphere by changing the sphere mesh's coarseness by using <code>-o 16 -a 16</code> and then <code>-o 128 -a 128</code>.
		</blockquote>

		<blockquote>
			Show a screenshot of your mirror shader on the cloth and on the sphere.
		</blockquote>

		<blockquote>
			Explain what you did in your custom shader, if you made one.
		</blockquote>

		<h2>(Optional) Part 6: Extra Credit - Additional cloth simulation features!</h2>
		
		</div>
	</body>
</html>